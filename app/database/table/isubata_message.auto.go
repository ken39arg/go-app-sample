// Code generated by genschema; DO NOT EDIT

package table

import (
	"database/sql"
	"fmt"
	"strings"

	sq "github.com/Masterminds/squirrel"
	"github.com/ken39arg/go-app-sample/app/database"
	"github.com/ken39arg/go-app-sample/app/database/row"
	"github.com/ken39arg/go-app-sample/app/enum"
	mtime "github.com/ken39arg/go-app-sample/app/time"
)

type IsubataMessage struct {
	c *database.DBClient
}

func NewIsubataMessage(c *database.DBClient) *IsubataMessage {
	return &IsubataMessage{c}
}

func (t *IsubataMessage) Name() string {
	return "isubata_message"
}

func (t *IsubataMessage) Columns() []string {
	return []string{"id", "channel_id", "user_id", "content", "created_at"}
}

func (t *IsubataMessage) ColumnsString() string {
	return "id,channel_id,user_id,content,created_at"
}

func (t *IsubataMessage) ScanRow(r *sql.Row) (*row.IsubataMessage, error) {
	v := row.IsubataMessage{}
	if err := r.Scan(&v.ID, &v.ChannelID, &v.UserID, &v.Content, &v.CreatedAt); err != nil {
		return nil, err
	}
	return &v, nil
}

func (t *IsubataMessage) ScanRows(r *sql.Rows) ([]*row.IsubataMessage, error) {
	ret := []*row.IsubataMessage{}
	for r.Next() {
		v := row.IsubataMessage{}
		if err := r.Scan(&v.ID, &v.ChannelID, &v.UserID, &v.Content, &v.CreatedAt); err != nil {
			return nil, err
		}
		ret = append(ret, &v)
	}
	if err := r.Err(); err != nil {
		return nil, err
	}
	return ret, nil
}

func (t *IsubataMessage) Refetch(v *row.IsubataMessage) error {
	query := "SELECT id,channel_id,user_id,content,created_at FROM isubata_message WHERE id = ? LIMIT 1"
	return t.c.DB().QueryRow(query, v.ID).Scan(
		&v.ID,
		&v.ChannelID,
		&v.UserID,
		&v.Content,
		&v.CreatedAt,
	)
}

func (t *IsubataMessage) RefetchForUpdate(v *row.IsubataMessage) error {
	if !t.c.InTransaction() {
		return fmt.Errorf("RefetchForUpdate should be called in transaction")
	}

	err := t.c.AddEndHook(func() { v.IsForUpdate = false })
	if err != nil {
		return err
	}
	v.IsForUpdate = true
	query := "SELECT id,channel_id,user_id,content,created_at FROM isubata_message WHERE id = ? LIMIT 1 FOR UPDATE"
	return t.c.DB().QueryRow(query, v.ID).Scan(
		&v.ID,
		&v.ChannelID,
		&v.UserID,
		&v.Content,
		&v.CreatedAt,
	)
}

func (t *IsubataMessage) Insert(v *row.IsubataMessage) error {

	v.CreatedAt = mtime.Now()

	_, err := t.c.DB().Exec("INSERT INTO isubata_message (id,channel_id,user_id,content,created_at) VALUES (?,?,?,?,?)", v.ID, v.ChannelID, v.UserID, v.Content, v.CreatedAt)
	return err
}

func (t *IsubataMessage) Update(v *row.IsubataMessage) error {

	query := "UPDATE isubata_message SET channel_id = ?,user_id = ?,content = ? WHERE id = ?"
	_, err := t.c.DB().Exec(query, v.ChannelID, v.UserID, v.Content, v.ID)
	if err != nil {
		return err
	}
	return nil
}

func (t *IsubataMessage) eachRowsFast(builder sq.SelectBuilder, fn func([]*row.IsubataMessage) error) error {
	builder = builder.OrderBy("id ASC").Limit(1000)

	itr := func(id int64) (int64, error) {
		query, args, err := builder.Where(sq.Gt{"id": id}).ToSql()
		if err != nil {
			return 0, err
		}
		rows, err := t.c.DB().Query(query, args...)
		if err != nil {
			return 0, err
		}
		defer rows.Close()

		rs, err := t.ScanRows(rows)
		if err != nil {
			return 0, err
		}

		var lastID int64
		if l := len(rs); l > 0 {
			lastID = rs[l-1].ID
		} else {
			return 0, nil
		}
		return lastID, fn(rs)
	}

	var lastID int64
	var err error
	for {
		lastID, err = itr(lastID)
		if err != nil {
			return err
		} else if lastID == 0 {
			break
		}
	}

	return nil
}

func (t *IsubataMessage) selectWithCursorID(builder sq.SelectBuilder, id int64, col string, order enum.PagerOrderType, perPage uint64) (rs []*row.IsubataMessage, prev, next int64, err error) {
	if order == enum.PagerNewer {
		if id != 0 {
			builder = builder.Where(sq.Gt{col: id})
		}
		builder = builder.OrderBy(col + " ASC")
	} else {
		if id != 0 {
			builder = builder.Where(sq.Lt{col: id})
		}
		builder = builder.OrderBy(col + " DESC")
	}

	query, args, err := builder.Limit(perPage + 1).ToSql()
	if err != nil {
		return
	}

	rows, err := t.c.DB().Query(query, args...)
	if err != nil {
		return
	}
	defer rows.Close()

	rs, err = t.ScanRows(rows)
	if err != nil {
		return
	}

	if len(rs) == 0 {
		return
	}

	if id != 0 {
		prev = rs[0].ID
	}
	if l := len(rs); uint64(l) > perPage {
		next = rs[l-2].ID
		rs = rs[:l-1]
	}

	if order == enum.PagerNewer {
		prev, next = next, prev
		for l, r := 0, len(rs)-1; l < r; l, r = l+1, r-1 {
			rs[l], rs[r] = rs[r], rs[l]
		}
	}

	return
}

func (t *IsubataMessage) FindByID(id int64) (*row.IsubataMessage, error) {
	query := "SELECT id,channel_id,user_id,content,created_at FROM isubata_message WHERE id = ? LIMIT 1"
	return t.ScanRow(t.c.DB().QueryRow(query, id))
}

func (t *IsubataMessage) FindAllByIDs(ids []int64) ([]*row.IsubataMessage, error) {
	l := len(ids)
	if 0 == l {
		return nil, nil
	}
	query := fmt.Sprintf("SELECT id,channel_id,user_id,content,created_at FROM isubata_message WHERE id IN (?%s)", strings.Repeat(",?", l-1))
	args := make([]interface{}, l)
	for i, v := range ids {
		args[i] = v
	}
	rows, err := t.c.DB().Query(query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	return t.ScanRows(rows)
}
