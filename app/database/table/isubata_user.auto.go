// Code generated by genschema; DO NOT EDIT

package table

import (
	"database/sql"
	"fmt"
	"strings"

	sq "github.com/Masterminds/squirrel"
	"github.com/ken39arg/go-app-sample/app/database"
	"github.com/ken39arg/go-app-sample/app/database/row"
	"github.com/ken39arg/go-app-sample/app/enum"
	mtime "github.com/ken39arg/go-app-sample/app/time"
)

type IsubataUser struct {
	c *database.DBClient
}

func NewIsubataUser(c *database.DBClient) *IsubataUser {
	return &IsubataUser{c}
}

func (t *IsubataUser) Name() string {
	return "isubata_user"
}

func (t *IsubataUser) Columns() []string {
	return []string{"id", "name", "salt", "pass", "display_name", "avatar_icon", "created_at"}
}

func (t *IsubataUser) ColumnsString() string {
	return "id,name,salt,pass,display_name,avatar_icon,created_at"
}

func (t *IsubataUser) ScanRow(r *sql.Row) (*row.IsubataUser, error) {
	v := row.IsubataUser{}
	if err := r.Scan(&v.ID, &v.Name, &v.Salt, &v.Pass, &v.DisplayName, &v.AvatarIcon, &v.CreatedAt); err != nil {
		return nil, err
	}
	return &v, nil
}

func (t *IsubataUser) ScanRows(r *sql.Rows) ([]*row.IsubataUser, error) {
	ret := []*row.IsubataUser{}
	for r.Next() {
		v := row.IsubataUser{}
		if err := r.Scan(&v.ID, &v.Name, &v.Salt, &v.Pass, &v.DisplayName, &v.AvatarIcon, &v.CreatedAt); err != nil {
			return nil, err
		}
		ret = append(ret, &v)
	}
	if err := r.Err(); err != nil {
		return nil, err
	}
	return ret, nil
}

func (t *IsubataUser) Refetch(v *row.IsubataUser) error {
	query := "SELECT id,name,salt,pass,display_name,avatar_icon,created_at FROM isubata_user WHERE id = ? LIMIT 1"
	return t.c.DB().QueryRow(query, v.ID).Scan(
		&v.ID,
		&v.Name,
		&v.Salt,
		&v.Pass,
		&v.DisplayName,
		&v.AvatarIcon,
		&v.CreatedAt,
	)
}

func (t *IsubataUser) RefetchForUpdate(v *row.IsubataUser) error {
	if !t.c.InTransaction() {
		return fmt.Errorf("RefetchForUpdate should be called in transaction")
	}

	err := t.c.AddEndHook(func() { v.IsForUpdate = false })
	if err != nil {
		return err
	}
	v.IsForUpdate = true
	query := "SELECT id,name,salt,pass,display_name,avatar_icon,created_at FROM isubata_user WHERE id = ? LIMIT 1 FOR UPDATE"
	return t.c.DB().QueryRow(query, v.ID).Scan(
		&v.ID,
		&v.Name,
		&v.Salt,
		&v.Pass,
		&v.DisplayName,
		&v.AvatarIcon,
		&v.CreatedAt,
	)
}

func (t *IsubataUser) Insert(v *row.IsubataUser) error {

	v.CreatedAt = mtime.Now()

	_, err := t.c.DB().Exec("INSERT INTO isubata_user (id,name,salt,pass,display_name,avatar_icon,created_at) VALUES (?,?,?,?,?,?,?)", v.ID, v.Name, v.Salt, v.Pass, v.DisplayName, v.AvatarIcon, v.CreatedAt)
	return err
}

func (t *IsubataUser) Update(v *row.IsubataUser) error {

	query := "UPDATE isubata_user SET name = ?,salt = ?,pass = ?,display_name = ?,avatar_icon = ? WHERE id = ?"
	_, err := t.c.DB().Exec(query, v.Name, v.Salt, v.Pass, v.DisplayName, v.AvatarIcon, v.ID)
	if err != nil {
		return err
	}
	return nil
}

func (t *IsubataUser) eachRowsFast(builder sq.SelectBuilder, fn func([]*row.IsubataUser) error) error {
	builder = builder.OrderBy("id ASC").Limit(1000)

	itr := func(id int64) (int64, error) {
		query, args, err := builder.Where(sq.Gt{"id": id}).ToSql()
		if err != nil {
			return 0, err
		}
		rows, err := t.c.DB().Query(query, args...)
		if err != nil {
			return 0, err
		}
		defer rows.Close()

		rs, err := t.ScanRows(rows)
		if err != nil {
			return 0, err
		}

		var lastID int64
		if l := len(rs); l > 0 {
			lastID = rs[l-1].ID
		} else {
			return 0, nil
		}
		return lastID, fn(rs)
	}

	var lastID int64
	var err error
	for {
		lastID, err = itr(lastID)
		if err != nil {
			return err
		} else if lastID == 0 {
			break
		}
	}

	return nil
}

func (t *IsubataUser) selectWithCursorID(builder sq.SelectBuilder, id int64, col string, order enum.PagerOrderType, perPage uint64) (rs []*row.IsubataUser, prev, next int64, err error) {
	if order == enum.PagerNewer {
		if id != 0 {
			builder = builder.Where(sq.Gt{col: id})
		}
		builder = builder.OrderBy(col + " ASC")
	} else {
		if id != 0 {
			builder = builder.Where(sq.Lt{col: id})
		}
		builder = builder.OrderBy(col + " DESC")
	}

	query, args, err := builder.Limit(perPage + 1).ToSql()
	if err != nil {
		return
	}

	rows, err := t.c.DB().Query(query, args...)
	if err != nil {
		return
	}
	defer rows.Close()

	rs, err = t.ScanRows(rows)
	if err != nil {
		return
	}

	if len(rs) == 0 {
		return
	}

	if id != 0 {
		prev = rs[0].ID
	}
	if l := len(rs); uint64(l) > perPage {
		next = rs[l-2].ID
		rs = rs[:l-1]
	}

	if order == enum.PagerNewer {
		prev, next = next, prev
		for l, r := 0, len(rs)-1; l < r; l, r = l+1, r-1 {
			rs[l], rs[r] = rs[r], rs[l]
		}
	}

	return
}

func (t *IsubataUser) FindByName(name string) (*row.IsubataUser, error) {
	query := "SELECT id,name,salt,pass,display_name,avatar_icon,created_at FROM isubata_user WHERE name = ? LIMIT 1"
	return t.ScanRow(t.c.DB().QueryRow(query, name))
}

func (t *IsubataUser) FindAllByNames(names []string) ([]*row.IsubataUser, error) {
	l := len(names)
	if 0 == l {
		return nil, nil
	}
	query := fmt.Sprintf("SELECT id,name,salt,pass,display_name,avatar_icon,created_at FROM isubata_user WHERE name IN (?%s)", strings.Repeat(",?", l-1))
	args := make([]interface{}, l)
	for i, v := range names {
		args[i] = v
	}
	rows, err := t.c.DB().Query(query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	return t.ScanRows(rows)
}

func (t *IsubataUser) FindByID(id int64) (*row.IsubataUser, error) {
	query := "SELECT id,name,salt,pass,display_name,avatar_icon,created_at FROM isubata_user WHERE id = ? LIMIT 1"
	return t.ScanRow(t.c.DB().QueryRow(query, id))
}

func (t *IsubataUser) FindAllByIDs(ids []int64) ([]*row.IsubataUser, error) {
	l := len(ids)
	if 0 == l {
		return nil, nil
	}
	query := fmt.Sprintf("SELECT id,name,salt,pass,display_name,avatar_icon,created_at FROM isubata_user WHERE id IN (?%s)", strings.Repeat(",?", l-1))
	args := make([]interface{}, l)
	for i, v := range ids {
		args[i] = v
	}
	rows, err := t.c.DB().Query(query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	return t.ScanRows(rows)
}
